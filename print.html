<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>UMPT 2020-2021 Team Tryout Contest Solution Booklet</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="overview.html">Overview</a></li><li class="chapter-item expanded "><a href="ann_arbor.html">A: Ann Arbor</a></li><li class="chapter-item expanded "><a href="bois_blanc.html">B: Bois Blanc</a></li><li class="chapter-item expanded "><a href="canton.html">C: Canton</a></li><li class="chapter-item expanded "><a href="detroit.html">D: Detroit</a></li><li class="chapter-item expanded "><a href="east_lansing.html">E: East Lansing</a></li><li class="chapter-item expanded "><a href="flint.html">F: Flint</a></li><li class="chapter-item expanded "><a href="grand_rabbits.html">G: Grand Rabbits</a></li><li class="chapter-item expanded "><a href="holland.html">H: Holland</a></li><li class="chapter-item expanded "><a href="isle_royale.html">I: Isle Royale</a></li><li class="chapter-item expanded "><a href="jackson.html">J: Jackson</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">UMPT 2020-2021 Team Tryout Contest Solution Booklet</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#overview" id="overview">Overview</a></h1>
<p>Contest can be accessed here at codeforces group: <a href="https://codeforces.com/group/62c8bIEN9G/contests">https://codeforces.com/group/62c8bIEN9G/contests</a></p>
<h2><a class="header" href="#some-statistics" id="some-statistics">Some Statistics</a></h2>
<table><thead><tr><th align="center">Problem</th><th align="center">Accepted Submissions</th><th align="center">First Accepted Time</th><th align="center">By</th></tr></thead><tbody>
<tr><td align="center">A</td><td align="center">13</td><td align="center">00:02</td><td align="center">runoxinabox</td></tr>
<tr><td align="center">B</td><td align="center">1</td><td align="center">02:40</td><td align="center">runoxinabox</td></tr>
<tr><td align="center">C</td><td align="center">11</td><td align="center">00:19</td><td align="center">pusheen</td></tr>
<tr><td align="center">D</td><td align="center">2</td><td align="center">00:45</td><td align="center">pusheen</td></tr>
<tr><td align="center">E</td><td align="center">3</td><td align="center">01:22</td><td align="center">ramchandra</td></tr>
<tr><td align="center">F</td><td align="center">5</td><td align="center">01:05</td><td align="center">ramchandra</td></tr>
<tr><td align="center">G</td><td align="center">2</td><td align="center">01:50</td><td align="center">ramchandra</td></tr>
<tr><td align="center">H</td><td align="center">0</td><td align="center">--</td><td align="center"></td></tr>
<tr><td align="center">I</td><td align="center">1</td><td align="center">02:03</td><td align="center">tonyb7</td></tr>
<tr><td align="center">J</td><td align="center">9</td><td align="center">00:16</td><td align="center">ranchandra</td></tr>
</tbody></table>
<h1><a class="header" href="#a-ann-arbor" id="a-ann-arbor">A: Ann Arbor</a></h1>
<h2><a class="header" href="#solution-sketch" id="solution-sketch">Solution Sketch</a></h2>
<p>Check for each day, and report the first index \(i\) such that \(a_i &lt; k\).</p>
<h2><a class="header" href="#sample-code-c" id="sample-code-c">Sample Code (C++)</a></h2>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;
 
int main() {
  int k, D, x;
  cin &gt;&gt; k &gt;&gt; D;
  for (int i = 0; i &lt; D; i++) {
    cin &gt;&gt; x;
    if (x &lt; k) {
      cout &lt;&lt; (i + 1) &lt;&lt; &quot;\n&quot;;
      return 0;
    }
  }
  cout &lt;&lt; &quot;awesome\n&quot;;
  return 0;
}
</code></pre>
<h1><a class="header" href="#b-bois-blanc" id="b-bois-blanc">B: Bois Blanc</a></h1>
<h2><a class="header" href="#solution-sketch-1" id="solution-sketch-1">Solution Sketch</a></h2>
<h3><a class="header" href="#first-part" id="first-part">First part</a></h3>
<p>The idea is that, for each lighthouse, we compute the range of lighting angles from the origin \((0, 0)\).
The subprocedure we need is to compute the intersection of the unit circle and some ray (half-line).
Suppose a lighthouse is located at \((x_i, y_i)\), with direction \(\alpha_i\) and vision \(\theta_i\).
Then this lighthouse creates two rays, which can be parametrized by</p>
<p>\(
\begin{cases}
x = x_i + t\cdot \cos (\alpha_i \pm \theta_i/2) \\
y = y_i + t\cdot \sin (\alpha_i \pm \theta_i/2) 
\end{cases}
\ \ (t &gt; 0)
\)</p>
<p>Bringing the above parametrized equations into \(x^2+y^2=1\) leads us to a quadratic equation of \(t\).
All we need is to solve for a positive \(t\) value, then convert it back in the angle form. (In C++ math library <code>atan2(y, x)</code> is a very helpful function!)</p>
<h3><a class="header" href="#second-part" id="second-part">Second part</a></h3>
<p>After we got all the angle ranges from the origin, we need to check whether or not these ranges cover the entire circumference. Here's a trick: since \(N \le 100\), we do not have to run the greedy algorithm that solves the circular covering problem.</p>
<p>We can discretize the entire circumference using range boundaries. This breaks the circumference into \(O(N)\) small segments. Then, we check for each segment (specifically, their <strong>midpoints</strong>), to see if each one is covered by some range. Time complexity here is \(O(N^2)\).</p>
<h2><a class="header" href="#sample-code-c-1" id="sample-code-c-1">Sample Code (C++)</a></h2>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;

const double PI = acos(-1.0);

double solve(double x, double y, double t) {
  // Returns the angle of elevation from the center, given the ray originated
  // from (x, y) with angle t.
  double A = 1.0;
  double B = 2 * x * cos(t) + 2 * y * sin(t);
  double C = x * x + y * y - 1.0;
  double Delta = B * B - 4 * A * C;
  double v = (-B + sqrt(B * B - 4 * A * C)) / 2.0;

  assert(v &gt; 0.0);
  double sx = x + v * cos(t);
  double sy = y + v * sin(t);
  return atan2(sy, sx);
}

bool inbetween(double q, double L, double R) {
  while (q &lt; 0) q += 2 * PI;
  while (q &gt; 2 * PI) q -= 2 * PI;
  if (L &lt;= q &amp;&amp; q &lt;= R) return true;
  if (L &lt;= q + 2 * PI &amp;&amp; q + 2 * PI &lt;= R) return true;
  if (L &lt;= q - 2 * PI &amp;&amp; q - 2 * PI &lt;= R) return true;
  return false;
}

int main() {
  int N;
  vector&lt;pair&lt;double, double&gt;&gt; a;
  vector&lt;double&gt; r;
  cin &gt;&gt; N;
  for (int i = 0; i &lt; N; i++) {
    double x, y, alpha, theta;
    cin &gt;&gt; x &gt;&gt; y &gt;&gt; alpha &gt;&gt; theta;

    double t1 = solve(x, y, alpha - theta / 2);
    double t2 = solve(x, y, alpha + theta / 2);
    if (t2 &lt; t1) t2 += 2 * PI;
    a.push_back({t1, t2});
    r.push_back(t1 - 2 * PI);
    r.push_back(t1);
    r.push_back(t1 + 2 * PI);
    r.push_back(t2 - 2 * PI);
    r.push_back(t2);
    r.push_back(t2 + 2 * PI);
  }

  sort(r.begin(), r.end());
  int badcount = 0;
  for (int i = 0; i + 1 &lt; r.size(); i++) {
    double t = (r[i] + r[i + 1]) / 2.0;
    int ok = 0;
    for (int j = 0; j &lt; N; j++) {
      if (inbetween(t, a[j].first, a[j].second)) ok = 1;
    }
    if (!ok) {
      puts(&quot;NO&quot;);
      return 0;
    }
  }

  puts(&quot;YES&quot;);
  return 0;
}
</code></pre>
<h1><a class="header" href="#c-canton" id="c-canton">C: Canton</a></h1>
<h2><a class="header" href="#solution-sketch-2" id="solution-sketch-2">Solution Sketch</a></h2>
<p>Usual DFS/BFS will solve this problem.</p>
<h2><a class="header" href="#sample-code-c-2" id="sample-code-c-2">Sample Code (C++)</a></h2>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;
 
int N, M, mxdepth = 0;
string a[2005];
char walk_and_mark(int x, int y, int depth = 0) {
  mxdepth = max(mxdepth, depth);
  if (!(x &gt;= 0 &amp;&amp; x &lt; N &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; M)) return '.';
 
  char dir = a[x][y];
  if (dir == '#') return dir;
  if (dir == '.') return dir;
  a[x][y] = '#';
  
  if (dir == 'N') return a[x][y] = walk_and_mark(x - 1, y, depth+1);
  if (dir == 'S') return a[x][y] = walk_and_mark(x + 1, y, depth+1);
  if (dir == 'E') return a[x][y] = walk_and_mark(x, y + 1, depth+1);
  if (dir == 'W') return a[x][y] = walk_and_mark(x, y - 1, depth+1);
  return '#';
}
 
int main() {
  cin &gt;&gt; N &gt;&gt; M;
  for (int i = 0; i &lt; N; i++) cin &gt;&gt; a[i];
  for (int i = 0; i &lt; N; i++)
    for (int j = 0; j &lt; M; j++) {
      if (a[i][j] &gt;= 'A' &amp;&amp; a[i][j] &lt;= 'Z') {
        walk_and_mark(i, j);
      }
    }
  int ans = 0;
  for (int i = 0; i &lt; N; i++)
    for (int j = 0; j &lt; M; j++) ans += (a[i][j] == '#');
  cout &lt;&lt; ans &lt;&lt; endl;
  return 0;
}
</code></pre>
<h1><a class="header" href="#d-detroit" id="d-detroit">D: Detroit</a></h1>
<h2><a class="header" href="#solution-sketch-3" id="solution-sketch-3">Solution Sketch</a></h2>
<p>This problem can be solved by dynamic programming.
For any subset of vertices \(S\) we define \(dp(S)\) to be the minimum number of edges needed where all vertices in \(S\) reaches vertex 1.</p>
<p>Using this definition, we notice that, for any edge \(e=(u, v)\) and any subset of vertices \(S\) that contains \(v\), we have \(dp(S\cup \{u\}) \le dp(S) + 1\).
Hence, we can iterate through every possible subset (from the smallest to the largest, when they are represented in binary numbers).
Within each iteration (with respect to the subset \(S\)), we consider all edges \((u, v)\) that reaches any vertex \(v\) in \(S\), and then update \(dp(S\cup \{u\})\) values accordingly.</p>
<p>The time complexity of the algorithm is \(O(2^N\cdot M)\).</p>
<h2><a class="header" href="#sample-code-c-3" id="sample-code-c-3">Sample Code (C++)</a></h2>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;

vector&lt;int&gt; a[25];
int goal = 0;
int dp[1 &lt;&lt; 20];

int main() {
  int N, M, K;
  cin &gt;&gt; N &gt;&gt; M &gt;&gt; K;
  for (int i = 0; i &lt; M; i++) {
    int x, y;
    cin &gt;&gt; x &gt;&gt; y;
    --x;
    --y;
    a[y].push_back(x);
  }
  for (int i = 1; i &lt;= K + 2; i++) {
    goal |= (1 &lt;&lt; (i - 1));
  }
  const int INF = 1e9;
  for (int state = 0; state &lt; (1 &lt;&lt; N); state++) dp[state] = INF;
  dp[1] = 0;
  int answer = INF;
  for (int state = 1; state &lt; (1 &lt;&lt; N); state++) {
    if (dp[state] == INF) continue;
    if ((goal &amp; state) == goal) {
      answer = min(answer, dp[state]);
      continue;
    }
    for (int i = 0; i &lt; N; i++)
      if (state &amp; (1 &lt;&lt; i)) {
        for (int j : a[i])
          if (!(state &amp; (1 &lt;&lt; j))) {
            int nextstate = (state | (1 &lt;&lt; j));
            dp[nextstate] = min(dp[nextstate], dp[state] + 1);
          }
      }
  }
  cout &lt;&lt; answer &lt;&lt; endl;
  return 0;
}
</code></pre>
<h1><a class="header" href="#e-east-lansing" id="e-east-lansing">E: East Lansing</a></h1>
<h2><a class="header" href="#solution-sketch-4" id="solution-sketch-4">Solution Sketch</a></h2>
<p>Since there are at most 10 question marks, we enumerate all possibilities of the t-shirt colors, and then run a naive BFS/DFS to count the connected components.</p>
<p>The time we need is about \(2^{10}MN\approx 10^7\).</p>
<h2><a class="header" href="#sample-code-c-4" id="sample-code-c-4">Sample Code (C++)</a></h2>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;

int N, M;
string a[105];

int compute() {
  int ret = 0;
  string v[105];

  for (int i = 0; i &lt; N; i++) v[i] = a[i];
  for (int i = 0; i &lt; N; i++)
    for (int j = 0; j &lt; M; j++)
      if (v[i][j] != '#') {
        ++ret;
        char c = v[i][j];
        queue&lt;int&gt; q;
        q.push(i);
        q.push(j);
        v[i][j] = '#';
        while (!q.empty()) {
          int x = q.front(); q.pop();
          int y = q.front(); q.pop();
          const int dx[4] = {1, 0, -1, 0};
          const int dy[4] = {0, 1, 0, -1};
          for (int f = 0; f &lt; 4; f++) {
            int nx = x + dx[f], ny = y + dy[f];
            if (nx &gt;= 0 &amp;&amp; nx &lt; N &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; M &amp;&amp; v[nx][ny] == c) {
              v[nx][ny] = '#';
              q.push(nx);
              q.push(ny);
            }
          }
        }
      }
  return ret;
}

int main() {
  cin &gt;&gt; N &gt;&gt; M;
  for (int i = 0; i &lt; N; i++) {
    cin &gt;&gt; a[i];
  }
  vector&lt;pair&lt;int, int&gt;&gt; p;
  for (int i = 0; i &lt; N; i++)
    for (int j = 0; j &lt; M; j++)
      if (a[i][j] == '?') p.push_back({i, j});

  int k = p.size();
  int answer = N * M;
  for (int state = 0; state &lt; (1 &lt;&lt; k); state++) {
    for (int i = 0; i &lt; k; i++)
      a[p[i].first][p[i].second] = '0' + !!(state &amp; (1 &lt;&lt; i));
    int c = compute();
    answer = min(answer, c);
  }
  cout &lt;&lt; answer &lt;&lt; endl;
  return 0;
}
</code></pre>
<h1><a class="header" href="#f-flint" id="f-flint">F: Flint</a></h1>
<h2><a class="header" href="#solution-sketch-5" id="solution-sketch-5">Solution Sketch</a></h2>
<p>For the ease of reading, for any set of integers \(S=\{s_1, s_2, \ldots, s_k\}\) we define \(\gcd(S) = \gcd(s_1, s_2, \ldots, s_k)\).</p>
<h3><a class="header" href="#the-dynamic-programming-approach" id="the-dynamic-programming-approach">The Dynamic Programming Approach</a></h3>
<p>Let \(dp(i, g)\) be the number of non-empty subsets among the first \(i\) elements where \(\gcd(S) = g\).
Then, when we consider a new element \(a_{i+1}\), we either add it to the subset or not. Hence, we can write the forward updating rule:</p>
<p>$$\begin{aligned}
dp(i+1, \gcd(g, a_{i+1})) &amp;\texttt{+= }  dp(i, g)\\
dp(i+1, g) &amp;\texttt{+= } dp(i, g)
\end{aligned}$$</p>
<p>How many possible gcd values will we have? Well, what we know for sure is that this value is always a factor of some input values \(a_j\). Hence, a very loose upper bound would be \(\sum_{i=1}^n d(a_i)\) where \(d(x)\) is the number of factors to \(x\). Given the input specification, we know that \(d(a_i)\le 2\sqrt{10^9}\approx 6.3\times 10^4\), so, the total time complexity is \(n\times \sum_{i=1}^n d(a_i) \approx 6.3\times 10^6\).</p>
<h3><a class="header" href="#the-inclusion-exclusion-approach-combinatorics--number-theory" id="the-inclusion-exclusion-approach-combinatorics--number-theory">The Inclusion-Exclusion Approach (Combinatorics + Number Theory)</a></h3>
<p>For any integer \(g\), it is very easy to compute the number of subsets \(S\) with \(\gcd(S)=g\). Using the idea of inclusion-exclusion, the answer can be computed by the formula below:</p>
<p>$$
\sum_{g=1}^\infty \mu(g) \left(2^{S_g} - 1\right)
$$</p>
<p>where \(\mu(g)\) is the <a href="https://en.wikipedia.org/wiki/M%C3%B6bius_function">Möbius function</a> and \(S_g\) is the number of integers that is divisible by \(g\) from the input.</p>
<p>Notice that the summands are non-zero only when \(g\) is a factor of some input value. Hence, the total time complexity here is simply \(\sum_{i=1}^n d(a_i) \approx 6.3\times 10^4\) plus the time you need to do factorization.</p>
<h2><a class="header" href="#sample-code-c-5" id="sample-code-c-5">Sample Code (C++)</a></h2>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;

const int MOD = 1e9 + 7;
int main() {
  int n;
  int a[105];
  long long two[105];
  map&lt;int, int&gt; cnt;
  map&lt;int, int&gt; mark;
  cin &gt;&gt; n;
  two[0] = 1;
  for (int i = 1; i &lt;= n; i++) two[i] = two[i - 1] * 2 % MOD;
  for (int i = 0; i &lt; n; i++) cin &gt;&gt; a[i];
  for (int i = 0; i &lt; n; i++) {
    int x = a[i];
    vector&lt;int&gt; pf;
    for (int p = 2; p * p &lt;= x; p++) {
      if (x % p == 0) {
        pf.push_back(p);
        while (x % p == 0) x /= p;
      }
    }

    if (x &gt; 1) pf.push_back(x);
    for (int state = 0; state &lt; (1 &lt;&lt; pf.size()); state++) {
      int g = 1, cc = 0;
      for (int j = 0; j &lt; pf.size(); j++) {
        if ((1 &lt;&lt; j) &amp; state) {
          ++cc;
          g *= pf[j];
        }
      }
      cnt[g]++;
      mark[g] = cc % 2;
    }
  }

  long long ans = 0;
  for (auto it : cnt) {
    int g = it.first, c = it.second;
    if (mark[g] == 0) {
      ans += two[c] - 1;
    } else {
      ans -= two[c] - 1;
    }
  }
  ans = (ans % MOD + MOD) % MOD;
  cout &lt;&lt; ans &lt;&lt; endl;
  return 0;
}
</code></pre>
<h1><a class="header" href="#g-grand-rabbits" id="g-grand-rabbits">G: Grand Rabbits</a></h1>
<h2><a class="header" href="#solution-sketch-6" id="solution-sketch-6">Solution Sketch</a></h2>
<p>Since \(k \le 10\), we can do binary search on the answer, and greedily (again on binary search) match each truck to a consecutive range of families.</p>
<p>The time complexity is \(QK\log N\approx 2\times 10^7\).</p>
<h2><a class="header" href="#sample-code-c-6" id="sample-code-c-6">Sample Code (C++)</a></h2>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;

long long a[100005];

int main() {
  cin.sync_with_stdio(false);
  cout.sync_with_stdio(false);
  int N, D;
  cin &gt;&gt; N &gt;&gt; D;
  for (int i = 1; i &lt;= N; i++) {
    cin &gt;&gt; a[i];
    a[i] += a[i - 1];
  }
  for (int i = 0; i &lt; D; i++) {
    int L, R, K;
    cin &gt;&gt; L &gt;&gt; R &gt;&gt; K;
    long long UB = (a[R] - a[L - 1]), LB = 0, answer = UB;
    while (LB &lt;= UB) {
      long long MID = (UB + LB) / 2;
      int s = L;
      long long v = a[L - 1], best_part = 0;
      for (int t = 0; t &lt; K &amp;&amp; s &lt;= R; t++) {
        s = upper_bound(a + L, a + R + 1, v + MID) - a;
        best_part = max(best_part, a[s - 1] - v);
        v = a[s - 1];
      }
      if (s &gt; R) {
        // Success: best_part &lt;= MID.
        answer = best_part;
        UB = best_part - 1;
      } else {
        LB = MID + 1;
      }
    }
    cout &lt;&lt; answer &lt;&lt; '\n';
  }
  return 0;
}
</code></pre>
<h1><a class="header" href="#h-holland" id="h-holland">H: Holland</a></h1>
<h2><a class="header" href="#solution-sketch-7" id="solution-sketch-7">Solution Sketch</a></h2>
<p>I believe this is the hardest problem in this contest.
The main idea to this problem, is to notice that the serving time is the same for all customers.
If people are lining up, the serving time is determined by the first person's arrival time plus some integer multiple of serving time.</p>
<p>So, we can apply greedy algorithm (to choose customer with largest tips) assuming a range of people are lining up after customer \(i\).
This gives us an algorithm that runs in \(O(N^2\log N)\) time.</p>
<h2><a class="header" href="#sample-code-c-7" id="sample-code-c-7">Sample Code (C++)</a></h2>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;
 
const int MAXN = 1005;
int main() {
  int N, K, S;
  vector&lt;pair&lt;int, int&gt;&gt; a;
  cin &gt;&gt; N &gt;&gt; K &gt;&gt; S;
  for(int i=0;i&lt;N;i++) {
    int ai, ti;
    cin &gt;&gt; ai &gt;&gt; ti;
    a.push_back({ai, ti});
  }
  
  sort(a.begin(), a.end());
  vector&lt;int&gt; dp(N+1, 0);
  for(int i=0;i&lt;N;i++) dp[i] = a[i].second;
 
  for(int i=N-1;i&gt;=0;i--) {
    dp[i] = max(dp[i], dp[i+1]);
    priority_queue&lt;pair&lt;int, int&gt;&gt; q;
 
    // invariant: slot[i] &lt;= K + i
    vector&lt;int&gt; slot(N, 0);
    slot[0]++;
 
    int now = a[i].second;
    int lastfull = -1;
 
    int j = i+1;
    for (int m = 1; j &lt; N || !q.empty(); m++) {
      slot[m] = slot[m-1];
      while (j &lt; N &amp;&amp; a[j].first &lt; a[i].first + S * m) {
        q.push({a[j].second, a[j].first});
        j++;
      }
      dp[i] = max(dp[i], now + dp[j]);
      int success = 0;
      while (!q.empty()) {
        int tip = q.top().first;
        int arrival = q.top().second;
        int arrival_slot = (arrival - a[i].first) / S;
        q.pop();
        // OK to put choose this element.
        if (arrival_slot &gt; lastfull) {
          // update tip
          now += tip;
 
          // update last full
          for(int w = arrival_slot; w &lt;= m; w++) {
            slot[w]++;
            if (slot[w] &gt;= K+w) lastfull = w;
          }
          success = 1;
          break;
        }
      }
      if (success == 0) break;
    }
 
    dp[i] = max(dp[i], now + dp[j]);
  }
 
  cout &lt;&lt; dp[0] &lt;&lt; endl;
  return 0;
}
</code></pre>
<h1><a class="header" href="#i-isle-royale" id="i-isle-royale">I: Isle Royale</a></h1>
<h2><a class="header" href="#solution-sketch-8" id="solution-sketch-8">Solution Sketch</a></h2>
<p>The main observation is that once the energy becomes zero, the problem reduces to the usual shortest path problem (that can be solved using Dijkstra's algorithm).</p>
<p>So, we first run Dijkstra's algorithm on the reversed graph from site \(N\). Then, we run an Bellman-Ford style algorithm that answers the following: if we arrive a site within \(steps\) minutes (without replenish the energy), what would be the smallest consumption of the enregy?</p>
<p>The total time complexity is \(O(NM)\).</p>
<h2><a class="header" href="#sample-code-c-8" id="sample-code-c-8">Sample Code (C++)</a></h2>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;
 
typedef pair&lt;long long, int&gt; PLI;
const int MAXN = 10005;
vector&lt;pair&lt;int, int&gt;&gt; a[MAXN];
int p[MAXN];
long long dist[MAXN];
 
int main() {
  int N, M, E;
  scanf(&quot;%d%d%d&quot;, &amp;N, &amp;M, &amp;E);
  for(int i=1;i&lt;=N-1;i++) scanf(&quot;%d&quot;, &amp;p[i]);
  p[N] = 0;
  for(int i=0;i&lt;M;i++) {
    int x, y, d;
    scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;d);
    a[x].push_back({y, d});
    a[y].push_back({x, d});
  }
  priority_queue&lt;PLI&gt; Q;
  Q.push(PLI(0, N));
  dist[N] = 0;
  const long long INF = 1LL&lt;&lt;60;
  for(int i=1;i&lt;N;i++) dist[i] = INF;
  while (!Q.empty()) {
    PLI z = Q.top(); Q.pop();
    long long d = -z.first;
    int x = z.second;
    if (dist[x] &lt; d) continue;
    for (auto&amp; v : a[x]) {
      int y = v.first;
      int r = v.second;
      long long newcost = dist[x] + r + 1 + p[y] + 1;
      if (newcost &lt; dist[y]) {
        dist[y] = newcost;
        Q.push(PLI(-dist[y], y));
      }
    }
  }
  // ==============================
  long long answer = INF;
  vector&lt;long long&gt; d2(N+1, INF);
  d2[1] = 0;
  for (int steps = 0; steps &lt; N; steps++) {
    vector&lt;long long&gt; d2nxt(N+1, INF);
    for(int x=1;x&lt;=N;x++) if (d2[x] != INF) for(auto&amp; v: a[x]) {
      int y = v.first;
      int r = v.second;
      long long newcost = d2[x] + p[x] + r;
      if (newcost &gt;= E) {
        answer = min(answer, 2 * steps + 2 + (newcost - E) + dist[y]);
      } else if (d2nxt[y] &gt; newcost) {
        answer = min(answer, 2 * steps + 2 + dist[y]);
        d2nxt[y] = newcost;
      }
    }
    d2.swap(d2nxt);
  }
 
  cout &lt;&lt; answer &lt;&lt; endl;
  return 0;
}
</code></pre>
<h1><a class="header" href="#j-jackson" id="j-jackson">J: Jackson</a></h1>
<h2><a class="header" href="#solution-sketch-9" id="solution-sketch-9">Solution Sketch</a></h2>
<p>This can be solved in a straight forward dynamic programming algorithm.</p>
<h2><a class="header" href="#sample-code-c-9" id="sample-code-c-9">Sample Code (C++)</a></h2>
<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;

int main() {
  string s;
  cin &gt;&gt; s;
  int n = s.size();
  string t = &quot;michigan&quot;;
  vector&lt;int&gt; dp(9, 0);
  const long long MOD = 1e9 + 7;
  dp[0] = 1;
  for (int i = 0, u = 0; i &lt; n; i++) {
    for (int j = 7; j &gt;= 0; j--) {
      dp[j + 1] = (dp[j + 1] + (s[i] == t[j] ? dp[j] : 0));
      if (dp[j + 1] &gt;= MOD) dp[j + 1] -= MOD;
    }
  }
  cout &lt;&lt; dp[8] &lt;&lt; endl;
  return 0;
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
